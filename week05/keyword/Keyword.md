- 환경 변수
    
    **정의**
    
    운영체제(OS)나 런타임 환경에서 프로그램이 실행될 때 참조하는 외부 설정값.
    
    API 키, DB 비밀번호, 포트 번호 등과 같은 **민감한 정보나 환경별 설정(dev/prod)** 을 코드 밖에서 관리.
    
    **특징**
    
    - 시스템 전역 또는 프로세스 단위로 설정 가능
    - `.env` 파일을 통해 관리 (Node.js는 `dotenv` 패키지 자주 사용)
    - OS 환경마다 달리 설정 가능 (리눅스: `export KEY=value`)
    
    **장점**
    
    - 코드와 설정 분리 → 보안 향상
    - 환경별 배포 (개발, 테스트, 운영) 시 유연성 확보
    
    **단점**
    
    - 관리 복잡 (환경별 변수 많아질 경우)
    - 노출 위험 (git에 .env 실수로 업로드 시 보안 사고)
    
    **정리**
    
    > “코드에 직접 비밀번호를 넣지 않고, 외부 환경에서 설정 정보를 주입하는 구조”
    > 
- CORS
    
    **정의**
    
    서버 리소스에 대한 요청이 **다른 도메인(origin)** 에서 발생할 때, 이를 허용할지 결정하는 **HTTP 보안 정책**.
    
    **특징**
    
    - 기본적으로 브라우저는 **동일 출처 정책(Same-Origin Policy)** 을 적용
    - 다른 도메인에서 접근하려면 서버가 **CORS 헤더(Access-Control-Allow-Origin 등)** 를 명시해야 함
    
    **장점**
    
    - 악의적인 사이트로부터 API 보호
    - 허용 도메인만 통신하도록 제어 가능
    
    **단점**
    
    - 서버/클라이언트 모두 설정이 번거로움
    - 개발 중 localhost 간 요청 시 자주 오류 발생
    
    **정리**
    
    > “다른 도메인 간 API 요청을 안전하게 허용하기 위한 브라우저 보안 정책”
    > 
- DB Connection, DB Connection Pool
    
    **정의**
    
    - **DB Connection**: 애플리케이션이 데이터베이스와 통신하기 위해 맺는 연결
    - **Connection Pool**: 여러 요청이 들어올 때 매번 새 연결을 만드는 대신, **재사용 가능한 연결을 미리 확보해두는 기술**
    
    **특징**
    
    - Spring Boot: `HikariCP` 기본 사용
    - Node.js: `mysql2/promise` 또는 `sequelize` 의 풀링 옵션 활용
    - 연결 개수(`maxConnections`)와 유지 시간(`timeout`) 조절 가능
    
    **장점**
    
    - 연결 재활용 → 성능 향상
    - DB 부하 감소, 자원 효율적 사용
    
    **단점**
    
    - 잘못된 설정 시 (pool 고갈, leak 등) 오히려 성능 저하
    - 연결 관리 복잡 (특히 대규모 트래픽 시)
    
    **정리**
    
    > “DB와의 연결을 매번 새로 여닫지 않고, 일정 수의 연결을 재활용하는 구조로 성능 최적화”
    > 
- 비동기 (async, await)
    
    **정의**
    
    하나의 작업이 완료되기 전에 다음 작업을 시작할 수 있는 **논블로킹(non-blocking)** 처리 방식.
    
    **특징**
    
    - JavaScript의 이벤트 루프 기반
    - `async` 함수 내에서 `await`로 **Promise의 결과를 기다릴 수 있음**
    - 동기 코드처럼 보이지만 내부적으로 비동기로 작동
    
    **장점**
    
    - I/O 대기 중에도 다른 작업 가능 → 효율적 자원 사용
    - 콜백 지옥(callback hell) 해결, 가독성 향상
    
    **단점**
    
    - 예외 처리가 복잡 (`try/catch`로 감싸야 함)
    - 병렬 실행 제어 필요 (`Promise.all`, `Promise.race` 등)
    
    **정리**
    
    > “순차적으로 보이지만 내부적으로 동시에 처리되는 코드 — 비동기 흐름의 핵심 키워드”
    > 
- try/catch/finally
    
    **정의**
    
    에러(예외) 발생 시 프로그램이 중단되지 않도록 **예외를 처리하는 구문**.
    
    **기본 구조**
    
    ```jsx
    try {
      // 실행할 코드
    } catch (err) {
      // 에러 발생 시 처리
    } finally {
      // 성공/실패 관계없이 항상 실행
    }
    
    ```
    
    **특징**
    
    - `try`: 예외가 발생할 가능성이 있는 코드
    - `catch`: 에러 객체를 받아 처리 (로그, 사용자 알림 등)
    - `finally`: 자원 해제, DB 연결 종료 등 항상 실행되는 블록
    
    **장점**
    
    - 안정적인 프로그램 실행
    - 예외 발생 위치를 명확히 제어 가능
    
    **단점**
    
    - 과도한 try/catch 사용 시 가독성 저하
    - 비동기 함수에서는 `await`와 함께 써야 예외 잡힘
    
    **정리**
    
    > “에러가 발생해도 프로그램이 죽지 않도록 흐름을 제어하는 안전장치”
    >